# Создание первой программы на Windows

```
global _start       ; делаем метку метку _start видимой извне
 
extern WriteFile        ; подключем функцию WriteFile
extern GetStdHandle     ; подключем функцию GetStdHandle
 
section .data   ; секция данных
message: db "Hello METANIT.COM!",10  ; строка для вывода на консоль
 
section .text       ; объявление секции кода
_start:             ; метка _start - точка входа в программу
    sub  rsp, 40   ; Для параметров функций WriteFile и GetStdHandle резервируем 40 байт (5 параметров по 8 байт)
    mov  rcx, -11  ; Аргумент для GetStdHandle - STD_OUTPUT
    call GetStdHandle ; вызываем функцию GetStdHandle
    mov  rcx, rax     ; Первый параметр WriteFile - в регистр RCX помещаем дескриптор файла - консоли
    mov  rdx, message    ; Второй параметр WriteFile - загружаем указатель на строку в регистр RDX
    mov  r8d, 18      ; Третий параметр WriteFile - длина строки для записи в регистре R8D 
    xor  r9, r9       ; Четвертый параметр WriteFile - адрес для получения записанных байтов
    mov  qword [rsp + 32], 0  ; Пятый параметр WriteFile
    call WriteFile ; вызываем функцию WriteFile
    add  rsp, 40
    ret             ; выход из программы
```

1. sub rsp, 40
Мы уменьшаем регистр стека (rsp) на 40 байт:

Это нужно для выделения места под аргументы функции WriteFile и вызова.

40 байт = 5 параметров по 8 байт (5×8=40).

2. mov rcx, -11
Это аргумент для GetStdHandle:

-11 (или 0xFFFFFFF5 в 16-ричном виде) — это специальное значение, которое обозначает дескриптор стандартного вывода (STD_OUTPUT_HANDLE).

3. mov r8d, 18
r8d — это младшие 32 бита регистра r8. В него записывается 18 (в десятичной системе):

Это размер строки, которую нужно вывести.

Строка Hello METANIT.COM! + символ новой строки (\n) = 18 байт.

4. mov qword [rsp + 32], 0
Здесь в памяти по адресу [rsp + 32] записывается 0.

Это пятый параметр функции WriteFile — указатель на переменную для числа записанных байтов. В нашем случае мы не хотим её использовать, поэтому передаем NULL (0).

Разберем эту программу. Для вывода строки на консоль нам надо использовать нативные функции GetStdHandle и WriteFile. И чтобы воспользоваться этими функциями подключаем их с помощью директивы extern

```
extern WriteFile
extern GetStdHandle
```

Далее идет определение секции данных - секции .data:

```
section .data   ; секция данных
message: db "Hello METANIT.COM!",10  ; строка для вывода на консоль
```

В секции .data определена метка message, на которую проецируется строка. По сути message - это переменная, которая представляет строку. После метки указывается тип данных. Строка в ассемблере - это просто набор байтов, поэтому имеет тип db. Затем в кавычках определяется собственно выводимая строка - "Hello METANIT.COM!",10. Обратите внимание на 10 после строки - это код символа перевода строки. То есть при выводе мы ожидаем, что будет происходить перевод на другую строку.

Затем идет секция кода - секция .text и метка _start - точка входа в программу

```
section .text       ; объявление секции кода
_start:             ; метка _start - точка входа в программу
```

В программе для вызова функций первым делом необходимо настроить стек. В частности, резервируем в стеке 40 байт для параметров функций GetStdHandle и WriteFile и при этом учитываем выравнивание стека по 16-байтной границе. Указатель на верхушку стека хранится в регистре rsp. Поэтому вычитаем с помощью инструкции sub из значения в регистре rsp 40 байт

```
sub rsp, 40
```

Почему 40? Прежде всего при вызове функций WinAPI (как в данном случае функций GetStdHandle и WriteFile) необходимо зарезервировать в стеке как минимум 32 байта - так называемое "shadow storage" (теневое хранилище). Далее нам надо учитывать количество параметров функции. Пеовые 4 параметра функций передаются через регистры, а параметры начиная с 5-го передаются через стек. Соответственно для 5-го и последующих параметров надо выделить в стеке область. Для каждого параметра вне зависимости от его размера выделяется 8 байт. Функция WriteFile как раз принимает 5 параметров, поэтому для нее надо выделить дополнительные 8 байт в стеке. Поэтому получаем 32 байта + 8 байт (5-й параметр WriteLine) = 40 байт. Количество параметров смотрим по функции с наибольшим количеством параметров. Третий момент - нам надо учитывать, что перед вызовом функций WinAPI стек имел выравнивание по 16 байтовой границе, то есть значение в RSP должно быть кратно 16. По умолчанию при вызове функции в стек помещается адрес возврата функии размером 8 байт. Поэтому наши 40 байт + 8 байт (адрес возврата из функции) дадут 48 байт - число кратное 16.

Вначале нам надо использовать встроенную функцию GetStdHandle(), которая позволяет получить дескриптор на устройство ввода-вывода. Она имеет следующее определение на C:

```
HANDLE WINAPI GetStdHandle(
  _In_ DWORD nStdHandle
);
```

Функция GetStdHandle() получает числовой код устройства, с которым мы хотим взаимодействовать. В нашем случае нам надо получить устройство стандартного вывода (для вывода строки), которым по умолчанию является консоль. Для обращения к консоли надо передать число -11, которое надо поместить в регистр rcx:

```
mov  rcx, -11  ; Аргумент для GetStdHandle - STD_OUTPUT
```

После установки параметра этой функции вызываем ее с помощью инструкции call:

```
call GetStdHandle
```

В результате выполнения функция GetStdHandle возвращает дескриптор - объект, через который мы можем взаимодействовать с консолью. Этот дескриптор помещается в регистр rax. Получив этот дескриптор, используем его для вывода на консоль строки с помощью функции WriteFile. Для справки ее определение на С++

```
BOOL WriteFile(
  [in]                HANDLE       hFile,
  [in]                LPCVOID      lpBuffer,
  [in]                DWORD        nNumberOfBytesToWrite,
  [out, optional]     LPDWORD      lpNumberOfBytesWritten,
  [in, out, optional] LPOVERLAPPED lpOverlapped
);
```

Вызов функции GetStdHandle помещает в регистр rax дескриптор консоли. И для вывода строкии на консоль с помощью функции WriteFile нам надо поместить этот дескриптор в регистр rcx

```
mov rcx, rax
```

Затем также с помощью инструкции mov загружаем в регистр rdx адрес выводимой строки

```
mov rdx, message
```

Далее в регистр r8d помещаем длину выводимой строки в байтах - в данном случае это 18 байт:

```
mov  r8d, 18
```

Поскольку у нас строка с символами ASCII, и каждый символ эквивалентен 1 байту, то получаем, что в строке message с учетом последнего символа с числовым кодом 10 будет 18 байт.

Затем в регистре r9 устанавливаем адрес четвертого параметра функции WriteFile:

```
xor  r9, r9
```

В данном случае нам не нужно количество считанных байтов, и с помощью инструкции xor обнуляем значение регистра r9.

Последний - пятый параметр функции WriteFile должен иметь значение NULL, по сути 0. Поэтому устанавливаем для него значение 0, смещаясь в стеке вперед на 32 байта (4 параметра * 8):

```
mov qword [rsp + 32], 0
```

Инструкция mov помещает значение в определенное место. Здесь в качестве значения служит число 0. А место определяется выражением qword [rsp + 32]. qword указывает, что этот операнд описывает адрес размером в четыре слова, что означает 8 байтов (слово имеет длину 2 байта). То есть число 0 представляет 8-байтное значение и помещается по адресу rsp + 32.

И далее собственно вызываем функцию WriteFile:

```
call WriteFile
```
Этот вызов должен привести к выводу строки на консоль. После этого восстанавливаем значение верхушки стека. Для этого с помощью инструкции add прибавляем к значению в регстре rsp ранее отнятые 40 байт:

```
add rsp, 40
```
И с помощью инструкции ret выходим из программы.


# Создание первой программы на Linux

```
global _start           ; делаем метку метку _start видимой извне
 
section .data   ; секция данных
message: db "Hello METANIT.COM!",10  ; строка для вывода на консоль
 
section .text           ; объявление секции кода
_start:                 ; объявление метки _start - точки входа в программу
    mov rax, 1          ; 1 - номер системного вызова функции write
    mov rdi, 1          ; 1 - дескриптор файла стандартного вызова stdout
    mov rsi, message    ; адрес строки для вывод
    mov rdx, 19         ; количество байтов
    syscall             ; выполняем системный вызов write
 
    mov rax, 60         ; 60 - номер системного вызова exit
    syscall             ; выполняем системный вызов exit
```
